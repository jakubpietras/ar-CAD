#version 460 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout(r32f, binding = 0) uniform image2D u_ImgOutput;

layout(std430, binding = 1) buffer b_Coords 
{
    vec4 Positions[];
};

layout(std430, binding = 2) buffer b_ErrorFlags
{
    int NonCuttingContact;
	int OverPlunge;
	int DownMilling;
};

uniform uint u_PathSegments;
uniform float u_BaseHeight;
uniform float u_CutterRadius;
uniform float u_CutterHeight;
uniform bool u_IsCutterFlat;
uniform float u_TexelWidth;
uniform float u_TexelHeight;
uniform float u_OffsetX;
uniform float u_OffsetY;

vec3 ProjectPointOntoSegment(vec3 p, vec3 start, vec3 end)
{
    vec3 segment = end - start;
    vec3 dir = p - start;
    float t = dot(segment, dir) / dot(segment, segment);
    t = clamp(t, 0.0f, 1.0f);
    return start + t * segment;
}

float CalculateDescFlat(vec3 q, vec3 p)
{
    if (q.z >= p.z)
        return 0.0f;
    return p.z - q.z;
}

float CalculateDescRound(vec3 q, vec3 p)
{
    // cutter's lowest point higher than the surface
    if (q.z >= p.z)
        return 0.0f;
    // surface within the space of the rounded part of the cutter
    float H = sqrt(u_CutterRadius * u_CutterRadius - dot(q.xy - p.xy, q.xy - p.xy));
    float height = q.z + (u_CutterRadius - H);
    if (height >= p.z)
        return 0.0f;
    return p.z - height;
}

bool DetectNonCuttingContact(vec3 q, vec3 p)
{
    float cuttingPartTop = q.z + (u_CutterHeight - u_CutterRadius);
    if (p.z > cuttingPartTop)
    {
        atomicCompSwap(NonCuttingContact, 0, 1);
        return true;
    }
    return false;
}

bool DetectOverPlunge(float currentHeight)
{
    if (currentHeight <= 0.0f)
    {
        atomicCompSwap(OverPlunge, 0, 1);
        return true;
    }
    return false;
}

bool DetectDownMilling(vec3 start, vec3 end, float descend, float eps)
{
    if (descend <= 0.0f)
        return false;
    
    vec3 dir = end - start;
    float segmentLength = length(dir);
    
    if (segmentLength < eps)
        return false;
    
    dir = normalize(dir);
    
    if (dir.z < (-1.0 + eps))
    {
        atomicCompSwap(DownMilling, 0, 1);
        return true;
    }
    return false;
}

void main()
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(u_ImgOutput);
    
    if (texelCoord.x >= imgSize.x || texelCoord.y >= imgSize.y)
        return;
    float currentHeight = imageLoad(u_ImgOutput, texelCoord).r;
    float descend = 0.0f;

    // corner of a heightmap cell
    vec3 p = vec3(
    u_OffsetX + texelCoord.x * u_TexelWidth,
    u_OffsetY + texelCoord.y * u_TexelHeight,
    u_BaseHeight + currentHeight
    );

    for (int seg = 0; seg < u_PathSegments; seg++)
    {
        vec3 start = Positions[seg].xyz;
        vec3 end = Positions[seg + 1].xyz;

        vec3 q = ProjectPointOntoSegment(p, start, end);
        if (dot(p.xy - q.xy, p.xy - q.xy) > u_CutterRadius * u_CutterRadius)
            continue;

        if (u_IsCutterFlat)
            descend = CalculateDescFlat(q, p);
        else
            descend = CalculateDescRound(q, p);

        
        currentHeight -= descend;
        p.z = u_BaseHeight + currentHeight;

        DetectNonCuttingContact(q, p);
        DetectOverPlunge(currentHeight);
        DetectDownMilling(start, end, descend, 1e-8);
    }
    imageStore(u_ImgOutput, texelCoord, vec4(currentHeight));
}

